<!DOCTYPE html>
<html>
    <head>
        <title>Grabbable Bricks!</title>
        <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
        <script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.1.0/dist/aframe-physics-system.js"></script>
        <script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>
        <script src="https://unpkg.com/aframe-physics-extras/dist/aframe-physics-extras.min.js"></script>

    </head>
<body>
  <a-scene physics environment="preset: tron; shadow: true">
    <a-sky color="#ECECEC"></a-sky>

    <a-assets>
        <a-mixin id="all-interactions" hoverable grabbable stretchable draggable
                 event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
                 event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
                 dynamic-body>
        </a-mixin>
    
        <a-mixin id="physics-hands" physics-collider phase-shift
                 collision-filter="collisionForces: false"
                 static-body="shape: sphere; sphereRadius: 0.02"
                 super-hands="colliderEvent: collisions;
                              colliderEventProperty: els;
                              colliderEndEvent: collisions;
                              colliderEndEventProperty: clearedEls;">
        </a-mixin>
        <a-mixin id="grab-move" grabbable draggable
             event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
             event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
             dynamic-body>
    </a-mixin>
    <a-mixin id="touch" physics-collider="" phase-shift="" collision-filter="collisionForces: false"
                 static-body="shape: sphere; sphereRadius: 0.02"
                 super-hands="colliderEvent: collisions; colliderEventProperty: els; colliderEndEvent: collisions; colliderEndEventProperty: clearedEls;">
        </a-mixin>

        <a-mixin id="cube" geometry="primitive: box; width: 0.33; height: 0.33; depth: 0.33"
                 hoverable="" grabbable="" stretchable="" draggable=""
                 event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
                 event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
                 dynamic-body="" shadow="">
        </a-mixin>
    </a-assets>
    

    <!-- Floor -->
    <a-plane position="0 0.5 -5" rotation="-90 0 0" width="10" height="10" color="#7B8C7C" static-body></a-plane>

    <!-- Walls -->
    <a-box position="0 3 -8" rotation="0 0 0" width="10" height="6" depth="0.2" color="#8B8589" static-body></a-box>
    <a-box position="-5 3 -5" rotation="0 90 0" width="10" height="6" depth="0.2" color="#8B8589" static-body></a-box>
    <a-box position="5 3 -5" rotation="0 90 0" width="10" height="6" depth="0.2" color="#8B8589" static-body></a-box>
    <a-box position="0 6 -5" rotation="90 0 0" width="10" height="10" depth="0.2" color="#8B8589" static-body></a-box>

    <!-- Window on the back wall -->
    <a-box position="0 3 -7.9" rotation="0 0 0" width="4" height="2" depth="0.1" color="#87CEEB" material="opacity: 0.5;" static-body></a-box>

    <!-- Potted Plant -->
    <a-cylinder position="-3 1 -4" radius="0.6" height="1" color="#654321" static-body></a-cylinder>
    <a-entity position="-3 1.5 -4">
        <a-cylinder radius="0.5" height="0.2" color="#228B22" static-body></a-cylinder>
        <a-cone position="0 0.5 0" radius-bottom="0.5" radius-top="0" height="1" color="#228B22" static-body></a-cone>
    </a-entity>

    <!-- Table -->
    <a-box position="0 1.2 -3" rotation="0 0 0" width="2" height="0.1" depth="1" color="#8B4513" static-body></a-box>
    <a-cylinder position="0.75 0.6 -2.75" radius="0.05" height="1.2" color="#8B4513" static-body></a-cylinder>
    <a-cylinder position="-0.75 0.6 -2.75" radius="0.05" height="1.2" color="#8B4513" static-body></a-cylinder>
    <a-cylinder position="0.75 0.6 -3.25" radius="0.05" height="1.2" color="#8B4513" static-body></a-cylinder>
    <a-cylinder position="-0.75 0.6 -3.25" radius="0.05" height="1.2" color="#8B4513" static-body></a-cylinder>

    <!-- Updated Brick entity with physics -->
    <a-box id="brick" class="cube" mixin="cube" position="0 1.65 -3" width="0.3" height="0.15" depth="0.15" color="#B22222"></a-box>


    <!-- Camera and controllers setup, unchanged -->
    <a-entity id="rig" custom-movement position="0 1 0">
        <a-camera position="0 -1 0"></a-camera>
        <a-entity id="rhand" mixin="touch" hand-controls="hand: right" thumbstick-movement custom-movement phase-shift super-hands></a-entity>
        <a-entity id="lhand" mixin="touch" hand-controls="hand: left" thumbstick-movement custom-movement phase-shift super-hands></a-entity>

    </a-entity>
    
    <script>
        AFRAME.registerComponent('phase-shift', {
            init: function () {
                var el = this.el;
                el.addEventListener('gripdown', function () {
                    el.setAttribute('collision-filter', {collisionForces: true});
                });
                el.addEventListener('gripup', function () {
                    el.setAttribute('collision-filter', {collisionForces: false});
                });
            }
        });
        AFRAME.registerComponent('custom-movement', {
    schema: {
      speed: {type: 'number', default: 0.1}
    },
    init: function () {
      window.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowUp':
          case 'w':
            this.moveForward();
            break;
          case 'ArrowDown':
          case 's':
            this.moveBackward();
            break;
          case 'ArrowLeft':
          case 'a':
            this.moveLeft();
            break;
          case 'ArrowRight':
          case 'd':
            this.moveRight();
            break;
        }
      });
    },
    moveForward: function() {
      const direction = new THREE.Vector3();
      this.el.object3D.getWorldDirection(direction);
      this.el.object3D.position.addScaledVector(direction, this.data.speed);
    },
    moveBackward: function() {
      const direction = new THREE.Vector3();
      this.el.object3D.getWorldDirection(direction);
      this.el.object3D.position.addScaledVector(direction, -this.data.speed);
    },
    moveLeft: function() {
      const direction = new THREE.Vector3();
      this.el.object3D.getWorldDirection(direction);
      direction.cross(this.el.object3D.up);
      this.el.object3D.position.addScaledVector(direction, -this.data.speed);
    },
    moveRight: function() {
      const direction = new THREE.Vector3();
      this.el.object3D.getWorldDirection(direction);
      direction.cross(this.el.object3D.up);
      this.el.object3D.position.addScaledVector(direction, this.data.speed);
    }
  });
  AFRAME.registerComponent('thumbstick-movement', {
  schema: {
    speed: {type: 'number', default: 0.05}, // Adjust speed as necessary for movement
    rotationSpeed: {type: 'number', default: 1.5} // Adjust speed as necessary for rotation
  },
  init: function () {
    this.el.addEventListener('thumbstickmoved', evt => {
      if (!evt.detail) return;
      
      let direction = new THREE.Vector3();
      let camEl = this.el.sceneEl.camera.el;

      // Get camera direction for forward/backward movement
      camEl.object3D.getWorldDirection(direction);
      direction.y = 0; // Ignore vertical component of the direction
      direction.normalize().multiplyScalar(evt.detail.y * this.data.speed);

      // Adjust for strafe movement based on thumbstick x-axis
      let strafeDirection = new THREE.Vector3();
      strafeDirection.crossVectors(direction, new THREE.Vector3(0, 1, 0)).multiplyScalar(evt.detail.x * this.data.speed);
      direction.add(strafeDirection);

      // Move the rig
      let rigEl = document.getElementById('rig');
      rigEl.object3D.position.add(direction);

      // Optional: Add rotation based on the x-axis of the other thumbstick
      // This assumes evt.detail.x is from the thumbstick designated for rotation
      // Adjust evt.detail.x to match the correct thumbstick input for your setup
      let rotation = evt.detail.x * this.data.rotationSpeed;
      rigEl.object3D.rotateY(THREE.Math.degToRad(rotation));
    });
  }
});

    </script>
    
</a-scene>
</body>
</html>
